<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器与Node的事件循环有何区别? | Learning Notes</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/blog/img/logo.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?914a62bca04ed9262c17f936d4f4961e";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
      </script>
    <meta name="description" content="">
    
    <link rel="preload" href="/blog/assets/css/0.styles.fddd0904.css" as="style"><link rel="preload" href="/blog/assets/js/app.d9867305.js" as="script"><link rel="preload" href="/blog/assets/js/2.d4a8e7da.js" as="script"><link rel="preload" href="/blog/assets/js/53.1e2a86db.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.0c131fdb.js"><link rel="prefetch" href="/blog/assets/js/11.2a827433.js"><link rel="prefetch" href="/blog/assets/js/12.53af4135.js"><link rel="prefetch" href="/blog/assets/js/13.70864a00.js"><link rel="prefetch" href="/blog/assets/js/14.988c8819.js"><link rel="prefetch" href="/blog/assets/js/15.e2e6fb33.js"><link rel="prefetch" href="/blog/assets/js/16.f29d73a1.js"><link rel="prefetch" href="/blog/assets/js/17.fd01d31d.js"><link rel="prefetch" href="/blog/assets/js/18.478b2abc.js"><link rel="prefetch" href="/blog/assets/js/19.50985e77.js"><link rel="prefetch" href="/blog/assets/js/20.611ed362.js"><link rel="prefetch" href="/blog/assets/js/21.25dc34a0.js"><link rel="prefetch" href="/blog/assets/js/22.336ea2f1.js"><link rel="prefetch" href="/blog/assets/js/23.1ea7d94c.js"><link rel="prefetch" href="/blog/assets/js/24.b25041d4.js"><link rel="prefetch" href="/blog/assets/js/25.c12e7b2e.js"><link rel="prefetch" href="/blog/assets/js/26.aae51b1d.js"><link rel="prefetch" href="/blog/assets/js/27.f75b88f7.js"><link rel="prefetch" href="/blog/assets/js/28.a1527721.js"><link rel="prefetch" href="/blog/assets/js/29.91eb89dc.js"><link rel="prefetch" href="/blog/assets/js/3.0b9fdc3c.js"><link rel="prefetch" href="/blog/assets/js/30.1c975490.js"><link rel="prefetch" href="/blog/assets/js/31.cc6a3ba5.js"><link rel="prefetch" href="/blog/assets/js/32.4dbede09.js"><link rel="prefetch" href="/blog/assets/js/33.e1bc475a.js"><link rel="prefetch" href="/blog/assets/js/34.3c3d121f.js"><link rel="prefetch" href="/blog/assets/js/35.6c60ea83.js"><link rel="prefetch" href="/blog/assets/js/36.0b58f1bc.js"><link rel="prefetch" href="/blog/assets/js/37.e6c55c18.js"><link rel="prefetch" href="/blog/assets/js/38.f0c6ebeb.js"><link rel="prefetch" href="/blog/assets/js/39.fe886b77.js"><link rel="prefetch" href="/blog/assets/js/4.bfe4e01c.js"><link rel="prefetch" href="/blog/assets/js/40.f6f6af0a.js"><link rel="prefetch" href="/blog/assets/js/41.f3e2249a.js"><link rel="prefetch" href="/blog/assets/js/42.b2cff4de.js"><link rel="prefetch" href="/blog/assets/js/43.36d4eaf4.js"><link rel="prefetch" href="/blog/assets/js/44.094c6e61.js"><link rel="prefetch" href="/blog/assets/js/45.0e9485fb.js"><link rel="prefetch" href="/blog/assets/js/46.e5cae4b1.js"><link rel="prefetch" href="/blog/assets/js/47.4ec0824f.js"><link rel="prefetch" href="/blog/assets/js/48.26970404.js"><link rel="prefetch" href="/blog/assets/js/49.bbf016c1.js"><link rel="prefetch" href="/blog/assets/js/5.963719b6.js"><link rel="prefetch" href="/blog/assets/js/50.99580640.js"><link rel="prefetch" href="/blog/assets/js/51.1d1a91fe.js"><link rel="prefetch" href="/blog/assets/js/52.6cb57362.js"><link rel="prefetch" href="/blog/assets/js/54.56c19ea4.js"><link rel="prefetch" href="/blog/assets/js/55.883ebca6.js"><link rel="prefetch" href="/blog/assets/js/56.986f3210.js"><link rel="prefetch" href="/blog/assets/js/57.1eb4ce5c.js"><link rel="prefetch" href="/blog/assets/js/58.447f3ff9.js"><link rel="prefetch" href="/blog/assets/js/59.6ad51c91.js"><link rel="prefetch" href="/blog/assets/js/6.72a1564d.js"><link rel="prefetch" href="/blog/assets/js/60.91a33088.js"><link rel="prefetch" href="/blog/assets/js/61.7ad07ab9.js"><link rel="prefetch" href="/blog/assets/js/62.0d6d10d0.js"><link rel="prefetch" href="/blog/assets/js/63.3d36e2ee.js"><link rel="prefetch" href="/blog/assets/js/64.831eeca7.js"><link rel="prefetch" href="/blog/assets/js/65.061a18b5.js"><link rel="prefetch" href="/blog/assets/js/66.aa4da67e.js"><link rel="prefetch" href="/blog/assets/js/67.a957c340.js"><link rel="prefetch" href="/blog/assets/js/68.f59d49f8.js"><link rel="prefetch" href="/blog/assets/js/7.fc65d3fd.js"><link rel="prefetch" href="/blog/assets/js/8.b78f75e5.js"><link rel="prefetch" href="/blog/assets/js/9.18f58ae2.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.fddd0904.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Learning Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/cacatalog/" class="nav-link">
  目录
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/html_css/" class="nav-link">
  HTML&amp;CSS
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/" class="nav-link">
  JavaScript
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记" class="dropdown-title"><span class="title">笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记" class="mobile-dropdown-title"><span class="title">笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/blog/note/" class="nav-link router-link-active">
  note
</a></li></ul></div></div><div class="nav-item"><a href="https://gitee.com/lb18237798919" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/lb18237798919" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/cacatalog/" class="nav-link">
  目录
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/html_css/" class="nav-link">
  HTML&amp;CSS
</a></li><li class="dropdown-item"><!----> <a href="/blog/javascript/" class="nav-link">
  JavaScript
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记" class="dropdown-title"><span class="title">笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记" class="mobile-dropdown-title"><span class="title">笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/blog/note/" class="nav-link router-link-active">
  note
</a></li></ul></div></div><div class="nav-item"><a href="https://gitee.com/lb18237798919" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/lb18237798919" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/html_css/" class="sidebar-heading clickable"><span>html&amp;css指南</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/html_css/html.html" class="sidebar-link">html 面试题</a></li><li><a href="/blog/html_css/css.html" class="sidebar-link">css 面试题</a></li><li><a href="/blog/html_css/css布局.html" class="sidebar-link">css 布局</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/javascript/" class="sidebar-heading clickable"><span>JavaScript指南</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/javascript/grammar/1.data_type.html#数据类型" class="sidebar-heading clickable open"><span>JavaScript基础</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/javascript/grammar/1.data_type.html" class="sidebar-link">数据类型</a></li><li><a href="/blog/javascript/grammar/2.oc.html" class="sidebar-link">相等运算符与比较运算符</a></li><li><a href="/blog/javascript/grammar/3.variable.html" class="sidebar-link">变量</a></li><li><a href="/blog/javascript/grammar/4.闭包.html" class="sidebar-link">闭包</a></li><li><a href="/blog/javascript/grammar/5.this.html" class="sidebar-link">this</a></li><li><a href="/blog/javascript/grammar/6.循环和遍历.html" class="sidebar-link">循环和遍历</a></li><li><a href="/blog/javascript/grammar/7.对象.html" class="sidebar-link">对象</a></li><li><a href="/blog/javascript/grammar/8.对象&amp;类&amp;函数.html" class="sidebar-link">对象&amp;类&amp;函数</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/javascript/ES6/1.变量的解构赋值.html#变量的解构赋值" class="sidebar-heading clickable"><span>ES6</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/javascript/JSWrite/1.数组常用api.html#数组常用api" class="sidebar-heading clickable"><span>JS手写系列</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/git/" class="sidebar-heading clickable"><span>git命令大全</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/git/git命令大全.html" class="sidebar-link">git</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/note/" class="sidebar-heading clickable router-link-active open"><span>note笔记</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/note/base/1.创建对象的四种方式.html" class="sidebar-heading clickable"><span>base</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/note/browser/1.介绍重绘和回流.html" class="sidebar-heading clickable open"><span>browser</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/note/browser/1.介绍重绘和回流.html" class="sidebar-link">1.介绍重绘和回流</a></li><li><a href="/blog/note/browser/2.浏览器与node的宏任务与微任务.html" class="active sidebar-link">2.浏览器与node的宏任务与微任务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/note/browser/2.浏览器与node的宏任务与微任务.html#一、线程与进程" class="sidebar-link">一、线程与进程</a></li><li class="sidebar-sub-header"><a href="/blog/note/browser/2.浏览器与node的宏任务与微任务.html#二、浏览器内核" class="sidebar-link">二、浏览器内核</a></li><li class="sidebar-sub-header"><a href="/blog/note/browser/2.浏览器与node的宏任务与微任务.html#三、浏览器中的-event-loop" class="sidebar-link">三、浏览器中的 Event Loop</a></li><li class="sidebar-sub-header"><a href="/blog/note/browser/2.浏览器与node的宏任务与微任务.html#四、node-中的-event-loop" class="sidebar-link">四、Node 中的 Event Loop</a></li><li class="sidebar-sub-header"><a href="/blog/note/browser/2.浏览器与node的宏任务与微任务.html#五、node与浏览器的-event-loop-差异" class="sidebar-link">五、Node与浏览器的 Event Loop 差异</a></li><li class="sidebar-sub-header"><a href="/blog/note/browser/2.浏览器与node的宏任务与微任务.html#六、总结" class="sidebar-link">六、总结</a></li></ul></li><li><a href="/blog/note/browser/3.浏览器缓存详解.html" class="sidebar-link">3.浏览器缓存详解</a></li><li><a href="/blog/note/browser/4.Token服务端身份验证的流行方案.html" class="sidebar-link">4.Token服务端身份验证的流行方案</a></li><li><a href="/blog/note/browser/5.前端与数据埋点.html" class="sidebar-link">5.前端与数据埋点</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/note/frame/1.vue面试常见面试题123.html" class="sidebar-heading clickable"><span>frame</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog/note/http＆https/1.了解HTTP与历史发展.html" class="sidebar-heading clickable"><span>http＆https</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器与node的事件循环有何区别"><a href="#浏览器与node的事件循环有何区别" class="header-anchor">#</a> 浏览器与Node的事件循环有何区别?</h1> <p>(Event Loop)</p> <h1 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h1> <p><strong>关于微任务和宏任务在浏览器的执行顺序是这样的：</strong></p> <ul><li>执行一只task（宏任务）</li> <li>执行完micro-task队列 （微任务）</li></ul> <p>如此循环往复下去</p> <blockquote><p>浏览器的task（宏任务）执行顺序在 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener noreferrer">html#event-loops<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 里面有讲就不翻译了 常见的 task（宏任务） 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。 常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。</p></blockquote> <h1 id="node"><a href="#node" class="header-anchor">#</a> Node</h1> <p>Node的事件循环是libuv实现的。</p> <p>大体的task（宏任务）执行顺序是这样的：</p> <ul><li>timers定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。</li> <li>pending callbacks待定回调：执行延迟到下一个循环迭代的 I/O 回调。</li> <li>idle, prepare：仅系统内部使用。</li> <li>poll 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。</li> <li>check 检测：setImmediate() 回调函数在这里执行。</li> <li>close callbacks 关闭的回调函数：一些准备关闭的回调函数，如：socket.on('close', ...)。</li></ul> <p><strong>微任务和宏任务在Node的执行顺序</strong></p> <p>Node 10以前：</p> <ul><li>执行完一个阶段的所有任务</li> <li>执行完nextTick队列里面的内容</li> <li>然后执行完微任务队列的内容</li></ul> <p>Node 11以后： 和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。</p> <h2 id="一、线程与进程"><a href="#一、线程与进程" class="header-anchor">#</a> 一、线程与进程</h2> <h3 id="_1-概念"><a href="#_1-概念" class="header-anchor">#</a> 1.概念</h3> <p>我们经常说JS 是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？</p> <p>官方的说法是：<strong>进程是 CPU资源分配的最小单位；线程是 CPU调度的最小单位</strong>。这两句话并不好理解，我们先来看张图：</p> <p><img src="img/168333c14c85d794" alt="img"></p> <ul><li>进程好比图中的工厂，有单独的专属自己的工厂资源。</li> <li>线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说<strong>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</strong>；</li> <li>工厂的空间是工人们共享的，这象征<strong>一个进程的内存空间是共享的，每个线程都可用这些共享内存</strong>。</li> <li>多个工厂之间独立存在。</li></ul> <h3 id="_2-多进程与多线程"><a href="#_2-多进程与多线程" class="header-anchor">#</a> 2.多进程与多线程</h3> <ul><li>多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li> <li>多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li></ul> <p>以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p> <h2 id="二、浏览器内核"><a href="#二、浏览器内核" class="header-anchor">#</a> 二、浏览器内核</h2> <p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p> <p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p> <ul><li>GUI 渲染线程</li> <li>JavaScript引擎线程</li> <li>定时触发器线程</li> <li>事件触发线程</li> <li>异步http请求线程</li></ul> <h3 id="_1-gui渲染线程"><a href="#_1-gui渲染线程" class="header-anchor">#</a> 1.GUI渲染线程</h3> <ul><li>主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。</li> <li>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。</li> <li>该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。</li></ul> <h3 id="_2-js引擎线程"><a href="#_2-js引擎线程" class="header-anchor">#</a> 2.JS引擎线程</h3> <ul><li>该线程当然是主要负责处理 JavaScript脚本，执行代码。</li> <li>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。</li> <li>当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。</li></ul> <h3 id="_3-定时器触发线程"><a href="#_3-定时器触发线程" class="header-anchor">#</a> 3.定时器触发线程</h3> <ul><li>负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。</li> <li>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。</li></ul> <h3 id="_4-事件触发线程"><a href="#_4-事件触发线程" class="header-anchor">#</a> 4.事件触发线程</h3> <ul><li>主要负责将准备好的事件交给 JS引擎线程执行。</li></ul> <p>比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。</p> <h3 id="_5-异步http请求线程"><a href="#_5-异步http请求线程" class="header-anchor">#</a> 5.异步http请求线程</h3> <ul><li>负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。</li> <li>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。</li></ul> <h2 id="三、浏览器中的-event-loop"><a href="#三、浏览器中的-event-loop" class="header-anchor">#</a> 三、浏览器中的 Event Loop</h2> <h3 id="_1-micro-task-与-macro-task"><a href="#_1-micro-task-与-macro-task" class="header-anchor">#</a> 1.Micro-Task 与 Macro-Task</h3> <p>浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。</p> <ul><li>常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。</li> <li>常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。</li></ul> <h3 id="_2-event-loop-过程解析"><a href="#_2-event-loop-过程解析" class="header-anchor">#</a> 2.Event Loop 过程解析</h3> <p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p> <p><img src="img/1683863633586974" alt="img"></p> <ul><li>一开始执行栈空,我们可以把<strong>执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li> <li>全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li> <li>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是<strong>一个一个</strong>执行的；而 micro-task 出队时，任务是<strong>一队一队</strong>执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</li> <li><strong>执行渲染操作，更新界面</strong></li> <li>检查是否存在 Web worker 任务，如果有，则对其进行处理</li> <li>上述过程循环往复，直到两个队列都清空</li></ul> <p>我们总结一下，每一次循环都是一个这样的过程：</p> <p><img src="img/1683877ba9aab056" alt="img"></p> <p><strong>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</strong></p> <p>接下来我们看道例子来介绍上面流程：</p> <div class="language- extra-class"><pre class="language-text"><code>Promise.resolve().then(()=&gt;{
  console.log('Promise1')  
  setTimeout(()=&gt;{
    console.log('setTimeout2')
  },0)
})
setTimeout(()=&gt;{
  console.log('setTimeout1')
  Promise.resolve().then(()=&gt;{
    console.log('Promise2')    
  })
},0)
复制代码
</code></pre></div><p>最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</p> <ul><li>一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2</li> <li>然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1</li> <li>在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2</li> <li>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</li></ul> <h2 id="四、node-中的-event-loop"><a href="#四、node-中的-event-loop" class="header-anchor">#</a> 四、Node 中的 Event Loop</h2> <h3 id="_1-node简介"><a href="#_1-node简介" class="header-anchor">#</a> 1.Node简介</h3> <p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）。</p> <p><img src="img/1683d81674f076eb" alt="img"></p> <p>Node.js的运行机制如下:</p> <ul><li>V8引擎解析JavaScript脚本。</li> <li>解析后的代码，调用Node API。</li> <li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li> <li>V8引擎再将结果返回给用户。</li></ul> <h3 id="_2-六个阶段"><a href="#_2-六个阶段" class="header-anchor">#</a> 2.六个阶段</h3> <p>其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p> <p><img src="img/16841bd9860c1ee9" alt="img"></p> <p>从上图中，大致看出node中的事件循环的顺序：</p> <p>外部输入数据--&gt;轮询阶段(poll)--&gt;检查阶段(check)--&gt;关闭事件回调阶段(close callback)--&gt;定时器检测阶段(timer)--&gt;I/O事件回调阶段(I/O callbacks)--&gt;闲置阶段(idle, prepare)--&gt;轮询阶段（按照该顺序反复运行）...</p> <ul><li>timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li> <li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li> <li>idle, prepare 阶段：仅node内部使用</li> <li>poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</li> <li>check 阶段：执行 setImmediate() 的回调</li> <li>close callbacks 阶段：执行 socket 的 close 事件回调</li></ul> <p>注意：<strong>上面六个阶段都不包括 process.nextTick()</strong>(下文会介绍)</p> <p>接下去我们详细介绍<code>timers</code>、<code>poll</code>、<code>check</code>这3个阶段，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。</p> <h4 id="_1-timer"><a href="#_1-timer" class="header-anchor">#</a> (1) timer</h4> <p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，<strong>在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行</strong>。</p> <h4 id="_2-poll"><a href="#_2-poll" class="header-anchor">#</a> (2) poll</h4> <p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p> <p>1.回到 timer 阶段执行回调</p> <p>2.执行 I/O 回调</p> <p>并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</p> <ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li> <li>如果 poll 队列为空时，会有两件事发生
<ul><li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li> <li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul> <p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p> <h4 id="_3-check阶段"><a href="#_3-check阶段" class="header-anchor">#</a> (3) check阶段</h4> <p>setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。 我们先来看个例子:</p> <div class="language- extra-class"><pre class="language-text"><code>console.log('start')
setTimeout(() =&gt; {
  console.log('timer1')
  Promise.resolve().then(function() {
    console.log('promise1')
  })
}, 0)
setTimeout(() =&gt; {
  console.log('timer2')
  Promise.resolve().then(function() {
    console.log('promise2')
  })
}, 0)
Promise.resolve().then(function() {
  console.log('promise3')
})
console.log('end')
//start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2
复制代码
</code></pre></div><ul><li>一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出start end，并将2个timer依次放入timer队列）,会先去执行微任务（<strong>这点跟浏览器端的一样</strong>），所以打印出promise3</li> <li>然后进入timers阶段，执行timer1的回调函数，打印timer1，并将promise.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；这点跟浏览器端相差比较大，<strong>timers阶段有几个setTimeout/setInterval都会依次执行</strong>，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于Node与浏览器的 Event Loop 差异，下文还会详细介绍）。</li></ul> <h3 id="_3-micro-task-与-macro-task"><a href="#_3-micro-task-与-macro-task" class="header-anchor">#</a> 3.Micro-Task 与 Macro-Task</h3> <p>Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。</p> <ul><li>常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。</li> <li>常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。</li></ul> <h3 id="_4-注意点"><a href="#_4-注意点" class="header-anchor">#</a> 4.注意点</h3> <h4 id="_1-settimeout-和-setimmediate"><a href="#_1-settimeout-和-setimmediate" class="header-anchor">#</a> (1) setTimeout 和 setImmediate</h4> <p>二者非常相似，区别主要在于调用时机不同。</p> <ul><li>setImmediate 设计在poll阶段完成时执行，即check阶段；</li> <li>setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行</li></ul> <div class="language- extra-class"><pre class="language-text"><code>setTimeout(function timeout () {
  console.log('timeout');
},0);
setImmediate(function immediate () {
  console.log('immediate');
});
复制代码
</code></pre></div><ul><li>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</li> <li>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</li> <li>如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了</li></ul> <p>但当二者在异步i/o callback内部调用时，总是先执行setImmediate，再执行setTimeout</p> <div class="language- extra-class"><pre class="language-text"><code>const fs = require('fs')
fs.readFile(__filename, () =&gt; {
    setTimeout(() =&gt; {
        console.log('timeout');
    }, 0)
    setImmediate(() =&gt; {
        console.log('immediate')
    })
})
// immediate
// timeout
复制代码
</code></pre></div><p>在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。</p> <h4 id="_2-process-nexttick"><a href="#_2-process-nexttick" class="header-anchor">#</a> (2) process.nextTick</h4> <p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p> <div class="language- extra-class"><pre class="language-text"><code>setTimeout(() =&gt; {
 console.log('timer1')
 Promise.resolve().then(function() {
   console.log('promise1')
 })
}, 0)
process.nextTick(() =&gt; {
 console.log('nextTick')
 process.nextTick(() =&gt; {
   console.log('nextTick')
   process.nextTick(() =&gt; {
     console.log('nextTick')
     process.nextTick(() =&gt; {
       console.log('nextTick')
     })
   })
 })
})
// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1
复制代码
</code></pre></div><h2 id="五、node与浏览器的-event-loop-差异"><a href="#五、node与浏览器的-event-loop-差异" class="header-anchor">#</a> 五、Node与浏览器的 Event Loop 差异</h2> <p><strong>浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务</strong>。</p> <p><img src="img/16841bad1cda741f" alt="img"></p> <p>接下我们通过一个例子来说明两者区别：</p> <div class="language- extra-class"><pre class="language-text"><code>setTimeout(()=&gt;{
    console.log('timer1')
    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)
setTimeout(()=&gt;{
    console.log('timer2')
    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)
复制代码
</code></pre></div><p>浏览器端运行结果：<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></p> <p>浏览器端的处理过程如下：</p> <p><img src="img/16841d6392e8f537" alt="img"></p> <p>Node端运行结果分两种情况：</p> <ul><li>如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li> <li>如果是node10及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。
<ul><li>如果是第二个定时器还未在完成队列中，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li> <li>如果是第二个定时器已经在完成队列中，则最后的结果为<code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code>(下文过程解释基于这种情况下)</li></ul></li></ul> <p>1.全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；</p> <p>2.首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；</p> <p>3.至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2</p> <p>Node端的处理过程如下：</p> <p><img src="img/16841d5f85468047" alt="img"></p> <h2 id="六、总结"><a href="#六、总结" class="header-anchor">#</a> 六、总结</h2> <p>浏览器和Node 环境下，microtask 任务队列的执行时机不同</p> <ul><li>Node端，microtask 在事件循环的各个阶段之间执行</li> <li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/note/browser/1.介绍重绘和回流.html" class="prev">
        1.介绍重绘和回流
      </a></span> <span class="next"><a href="/blog/note/browser/3.浏览器缓存详解.html">
        3.浏览器缓存详解
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.d9867305.js" defer></script><script src="/blog/assets/js/2.d4a8e7da.js" defer></script><script src="/blog/assets/js/53.1e2a86db.js" defer></script>
  </body>
</html>
