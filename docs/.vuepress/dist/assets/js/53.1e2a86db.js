(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{415:function(e,t,s){"use strict";s.r(t);var v=s(42),i=Object(v.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"浏览器与node的事件循环有何区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器与node的事件循环有何区别"}},[e._v("#")]),e._v(" 浏览器与Node的事件循环有何区别?")]),e._v(" "),s("p",[e._v("(Event Loop)")]),e._v(" "),s("h1",{attrs:{id:"浏览器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[e._v("#")]),e._v(" 浏览器")]),e._v(" "),s("p",[s("strong",[e._v("关于微任务和宏任务在浏览器的执行顺序是这样的：")])]),e._v(" "),s("ul",[s("li",[e._v("执行一只task（宏任务）")]),e._v(" "),s("li",[e._v("执行完micro-task队列 （微任务）")])]),e._v(" "),s("p",[e._v("如此循环往复下去")]),e._v(" "),s("blockquote",[s("p",[e._v("浏览器的task（宏任务）执行顺序在 "),s("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/webappapis.html#event-loops",target:"_blank",rel:"noopener noreferrer"}},[e._v("html#event-loops"),s("OutboundLink")],1),e._v(" 里面有讲就不翻译了 常见的 task（宏任务） 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。 常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。")])]),e._v(" "),s("h1",{attrs:{id:"node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node"}},[e._v("#")]),e._v(" Node")]),e._v(" "),s("p",[e._v("Node的事件循环是libuv实现的。")]),e._v(" "),s("p",[e._v("大体的task（宏任务）执行顺序是这样的：")]),e._v(" "),s("ul",[s("li",[e._v("timers定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。")]),e._v(" "),s("li",[e._v("pending callbacks待定回调：执行延迟到下一个循环迭代的 I/O 回调。")]),e._v(" "),s("li",[e._v("idle, prepare：仅系统内部使用。")]),e._v(" "),s("li",[e._v("poll 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。")]),e._v(" "),s("li",[e._v("check 检测：setImmediate() 回调函数在这里执行。")]),e._v(" "),s("li",[e._v("close callbacks 关闭的回调函数：一些准备关闭的回调函数，如：socket.on('close', ...)。")])]),e._v(" "),s("p",[s("strong",[e._v("微任务和宏任务在Node的执行顺序")])]),e._v(" "),s("p",[e._v("Node 10以前：")]),e._v(" "),s("ul",[s("li",[e._v("执行完一个阶段的所有任务")]),e._v(" "),s("li",[e._v("执行完nextTick队列里面的内容")]),e._v(" "),s("li",[e._v("然后执行完微任务队列的内容")])]),e._v(" "),s("p",[e._v("Node 11以后： 和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。")]),e._v(" "),s("h2",{attrs:{id:"一、线程与进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、线程与进程"}},[e._v("#")]),e._v(" 一、线程与进程")]),e._v(" "),s("h3",{attrs:{id:"_1-概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[e._v("#")]),e._v(" 1.概念")]),e._v(" "),s("p",[e._v("我们经常说JS 是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？")]),e._v(" "),s("p",[e._v("官方的说法是："),s("strong",[e._v("进程是 CPU资源分配的最小单位；线程是 CPU调度的最小单位")]),e._v("。这两句话并不好理解，我们先来看张图：")]),e._v(" "),s("p",[s("img",{attrs:{src:"img/168333c14c85d794",alt:"img"}})]),e._v(" "),s("ul",[s("li",[e._v("进程好比图中的工厂，有单独的专属自己的工厂资源。")]),e._v(" "),s("li",[e._v("线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说"),s("strong",[e._v("一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线")]),e._v("；")]),e._v(" "),s("li",[e._v("工厂的空间是工人们共享的，这象征"),s("strong",[e._v("一个进程的内存空间是共享的，每个线程都可用这些共享内存")]),e._v("。")]),e._v(" "),s("li",[e._v("多个工厂之间独立存在。")])]),e._v(" "),s("h3",{attrs:{id:"_2-多进程与多线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-多进程与多线程"}},[e._v("#")]),e._v(" 2.多进程与多线程")]),e._v(" "),s("ul",[s("li",[e._v("多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。")]),e._v(" "),s("li",[e._v("多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。")])]),e._v(" "),s("p",[e._v("以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。")]),e._v(" "),s("h2",{attrs:{id:"二、浏览器内核"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、浏览器内核"}},[e._v("#")]),e._v(" 二、浏览器内核")]),e._v(" "),s("p",[e._v("简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。")]),e._v(" "),s("p",[e._v("浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：")]),e._v(" "),s("ul",[s("li",[e._v("GUI 渲染线程")]),e._v(" "),s("li",[e._v("JavaScript引擎线程")]),e._v(" "),s("li",[e._v("定时触发器线程")]),e._v(" "),s("li",[e._v("事件触发线程")]),e._v(" "),s("li",[e._v("异步http请求线程")])]),e._v(" "),s("h3",{attrs:{id:"_1-gui渲染线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-gui渲染线程"}},[e._v("#")]),e._v(" 1.GUI渲染线程")]),e._v(" "),s("ul",[s("li",[e._v("主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。")]),e._v(" "),s("li",[e._v("当界面需要重绘或者由于某种操作引发回流时，将执行该线程。")]),e._v(" "),s("li",[e._v("该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。")])]),e._v(" "),s("h3",{attrs:{id:"_2-js引擎线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-js引擎线程"}},[e._v("#")]),e._v(" 2.JS引擎线程")]),e._v(" "),s("ul",[s("li",[e._v("该线程当然是主要负责处理 JavaScript脚本，执行代码。")]),e._v(" "),s("li",[e._v("也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。")]),e._v(" "),s("li",[e._v("当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。")])]),e._v(" "),s("h3",{attrs:{id:"_3-定时器触发线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-定时器触发线程"}},[e._v("#")]),e._v(" 3.定时器触发线程")]),e._v(" "),s("ul",[s("li",[e._v("负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。")]),e._v(" "),s("li",[e._v("主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。")])]),e._v(" "),s("h3",{attrs:{id:"_4-事件触发线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-事件触发线程"}},[e._v("#")]),e._v(" 4.事件触发线程")]),e._v(" "),s("ul",[s("li",[e._v("主要负责将准备好的事件交给 JS引擎线程执行。")])]),e._v(" "),s("p",[e._v("比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。")]),e._v(" "),s("h3",{attrs:{id:"_5-异步http请求线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-异步http请求线程"}},[e._v("#")]),e._v(" 5.异步http请求线程")]),e._v(" "),s("ul",[s("li",[e._v("负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。")]),e._v(" "),s("li",[e._v("主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。")])]),e._v(" "),s("h2",{attrs:{id:"三、浏览器中的-event-loop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、浏览器中的-event-loop"}},[e._v("#")]),e._v(" 三、浏览器中的 Event Loop")]),e._v(" "),s("h3",{attrs:{id:"_1-micro-task-与-macro-task"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-micro-task-与-macro-task"}},[e._v("#")]),e._v(" 1.Micro-Task 与 Macro-Task")]),e._v(" "),s("p",[e._v("浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。")]),e._v(" "),s("ul",[s("li",[e._v("常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。")]),e._v(" "),s("li",[e._v("常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。")])]),e._v(" "),s("h3",{attrs:{id:"_2-event-loop-过程解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-event-loop-过程解析"}},[e._v("#")]),e._v(" 2.Event Loop 过程解析")]),e._v(" "),s("p",[e._v("一个完整的 Event Loop 过程，可以概括为以下阶段：")]),e._v(" "),s("p",[s("img",{attrs:{src:"img/1683863633586974",alt:"img"}})]),e._v(" "),s("ul",[s("li",[e._v("一开始执行栈空,我们可以把"),s("strong",[e._v("执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则")]),e._v("。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。")]),e._v(" "),s("li",[e._v("全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。")]),e._v(" "),s("li",[e._v("上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是"),s("strong",[e._v("一个一个")]),e._v("执行的；而 micro-task 出队时，任务是"),s("strong",[e._v("一队一队")]),e._v("执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。")]),e._v(" "),s("li",[s("strong",[e._v("执行渲染操作，更新界面")])]),e._v(" "),s("li",[e._v("检查是否存在 Web worker 任务，如果有，则对其进行处理")]),e._v(" "),s("li",[e._v("上述过程循环往复，直到两个队列都清空")])]),e._v(" "),s("p",[e._v("我们总结一下，每一次循环都是一个这样的过程：")]),e._v(" "),s("p",[s("img",{attrs:{src:"img/1683877ba9aab056",alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。")])]),e._v(" "),s("p",[e._v("接下来我们看道例子来介绍上面流程：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Promise.resolve().then(()=>{\n  console.log('Promise1')  \n  setTimeout(()=>{\n    console.log('setTimeout2')\n  },0)\n})\nsetTimeout(()=>{\n  console.log('setTimeout1')\n  Promise.resolve().then(()=>{\n    console.log('Promise2')    \n  })\n},0)\n复制代码\n")])])]),s("p",[e._v("最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2")]),e._v(" "),s("ul",[s("li",[e._v("一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2")]),e._v(" "),s("li",[e._v("然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1")]),e._v(" "),s("li",[e._v("在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2")]),e._v(" "),s("li",[e._v("清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2")])]),e._v(" "),s("h2",{attrs:{id:"四、node-中的-event-loop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、node-中的-event-loop"}},[e._v("#")]),e._v(" 四、Node 中的 Event Loop")]),e._v(" "),s("h3",{attrs:{id:"_1-node简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-node简介"}},[e._v("#")]),e._v(" 1.Node简介")]),e._v(" "),s("p",[e._v("Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）。")]),e._v(" "),s("p",[s("img",{attrs:{src:"img/1683d81674f076eb",alt:"img"}})]),e._v(" "),s("p",[e._v("Node.js的运行机制如下:")]),e._v(" "),s("ul",[s("li",[e._v("V8引擎解析JavaScript脚本。")]),e._v(" "),s("li",[e._v("解析后的代码，调用Node API。")]),e._v(" "),s("li",[e._v("libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。")]),e._v(" "),s("li",[e._v("V8引擎再将结果返回给用户。")])]),e._v(" "),s("h3",{attrs:{id:"_2-六个阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-六个阶段"}},[e._v("#")]),e._v(" 2.六个阶段")]),e._v(" "),s("p",[e._v("其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。")]),e._v(" "),s("p",[s("img",{attrs:{src:"img/16841bd9860c1ee9",alt:"img"}})]),e._v(" "),s("p",[e._v("从上图中，大致看出node中的事件循环的顺序：")]),e._v(" "),s("p",[e._v("外部输入数据--\x3e轮询阶段(poll)--\x3e检查阶段(check)--\x3e关闭事件回调阶段(close callback)--\x3e定时器检测阶段(timer)--\x3eI/O事件回调阶段(I/O callbacks)--\x3e闲置阶段(idle, prepare)--\x3e轮询阶段（按照该顺序反复运行）...")]),e._v(" "),s("ul",[s("li",[e._v("timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调")]),e._v(" "),s("li",[e._v("I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调")]),e._v(" "),s("li",[e._v("idle, prepare 阶段：仅node内部使用")]),e._v(" "),s("li",[e._v("poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里")]),e._v(" "),s("li",[e._v("check 阶段：执行 setImmediate() 的回调")]),e._v(" "),s("li",[e._v("close callbacks 阶段：执行 socket 的 close 事件回调")])]),e._v(" "),s("p",[e._v("注意："),s("strong",[e._v("上面六个阶段都不包括 process.nextTick()")]),e._v("(下文会介绍)")]),e._v(" "),s("p",[e._v("接下去我们详细介绍"),s("code",[e._v("timers")]),e._v("、"),s("code",[e._v("poll")]),e._v("、"),s("code",[e._v("check")]),e._v("这3个阶段，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。")]),e._v(" "),s("h4",{attrs:{id:"_1-timer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-timer"}},[e._v("#")]),e._v(" (1) timer")]),e._v(" "),s("p",[e._v("timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，"),s("strong",[e._v("在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行")]),e._v("。")]),e._v(" "),s("h4",{attrs:{id:"_2-poll"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-poll"}},[e._v("#")]),e._v(" (2) poll")]),e._v(" "),s("p",[e._v("poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情")]),e._v(" "),s("p",[e._v("1.回到 timer 阶段执行回调")]),e._v(" "),s("p",[e._v("2.执行 I/O 回调")]),e._v(" "),s("p",[e._v("并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情")]),e._v(" "),s("ul",[s("li",[e._v("如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制")]),e._v(" "),s("li",[e._v("如果 poll 队列为空时，会有两件事发生\n"),s("ul",[s("li",[e._v("如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调")]),e._v(" "),s("li",[e._v("如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去")])])])]),e._v(" "),s("p",[e._v("当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。")]),e._v(" "),s("h4",{attrs:{id:"_3-check阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-check阶段"}},[e._v("#")]),e._v(" (3) check阶段")]),e._v(" "),s("p",[e._v("setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。 我们先来看个例子:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("console.log('start')\nsetTimeout(() => {\n  console.log('timer1')\n  Promise.resolve().then(function() {\n    console.log('promise1')\n  })\n}, 0)\nsetTimeout(() => {\n  console.log('timer2')\n  Promise.resolve().then(function() {\n    console.log('promise2')\n  })\n}, 0)\nPromise.resolve().then(function() {\n  console.log('promise3')\n})\nconsole.log('end')\n//start=>end=>promise3=>timer1=>timer2=>promise1=>promise2\n复制代码\n")])])]),s("ul",[s("li",[e._v("一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出start end，并将2个timer依次放入timer队列）,会先去执行微任务（"),s("strong",[e._v("这点跟浏览器端的一样")]),e._v("），所以打印出promise3")]),e._v(" "),s("li",[e._v("然后进入timers阶段，执行timer1的回调函数，打印timer1，并将promise.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；这点跟浏览器端相差比较大，"),s("strong",[e._v("timers阶段有几个setTimeout/setInterval都会依次执行")]),e._v("，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于Node与浏览器的 Event Loop 差异，下文还会详细介绍）。")])]),e._v(" "),s("h3",{attrs:{id:"_3-micro-task-与-macro-task"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-micro-task-与-macro-task"}},[e._v("#")]),e._v(" 3.Micro-Task 与 Macro-Task")]),e._v(" "),s("p",[e._v("Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。")]),e._v(" "),s("ul",[s("li",[e._v("常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。")]),e._v(" "),s("li",[e._v("常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。")])]),e._v(" "),s("h3",{attrs:{id:"_4-注意点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-注意点"}},[e._v("#")]),e._v(" 4.注意点")]),e._v(" "),s("h4",{attrs:{id:"_1-settimeout-和-setimmediate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-settimeout-和-setimmediate"}},[e._v("#")]),e._v(" (1) setTimeout 和 setImmediate")]),e._v(" "),s("p",[e._v("二者非常相似，区别主要在于调用时机不同。")]),e._v(" "),s("ul",[s("li",[e._v("setImmediate 设计在poll阶段完成时执行，即check阶段；")]),e._v(" "),s("li",[e._v("setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("setTimeout(function timeout () {\n  console.log('timeout');\n},0);\nsetImmediate(function immediate () {\n  console.log('immediate');\n});\n复制代码\n")])])]),s("ul",[s("li",[e._v("对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。")]),e._v(" "),s("li",[e._v("首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调")]),e._v(" "),s("li",[e._v("如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了")])]),e._v(" "),s("p",[e._v("但当二者在异步i/o callback内部调用时，总是先执行setImmediate，再执行setTimeout")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const fs = require('fs')\nfs.readFile(__filename, () => {\n    setTimeout(() => {\n        console.log('timeout');\n    }, 0)\n    setImmediate(() => {\n        console.log('immediate')\n    })\n})\n// immediate\n// timeout\n复制代码\n")])])]),s("p",[e._v("在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。")]),e._v(" "),s("h4",{attrs:{id:"_2-process-nexttick"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-process-nexttick"}},[e._v("#")]),e._v(" (2) process.nextTick")]),e._v(" "),s("p",[e._v("这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("setTimeout(() => {\n console.log('timer1')\n Promise.resolve().then(function() {\n   console.log('promise1')\n })\n}, 0)\nprocess.nextTick(() => {\n console.log('nextTick')\n process.nextTick(() => {\n   console.log('nextTick')\n   process.nextTick(() => {\n     console.log('nextTick')\n     process.nextTick(() => {\n       console.log('nextTick')\n     })\n   })\n })\n})\n// nextTick=>nextTick=>nextTick=>nextTick=>timer1=>promise1\n复制代码\n")])])]),s("h2",{attrs:{id:"五、node与浏览器的-event-loop-差异"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、node与浏览器的-event-loop-差异"}},[e._v("#")]),e._v(" 五、Node与浏览器的 Event Loop 差异")]),e._v(" "),s("p",[s("strong",[e._v("浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务")]),e._v("。")]),e._v(" "),s("p",[s("img",{attrs:{src:"img/16841bad1cda741f",alt:"img"}})]),e._v(" "),s("p",[e._v("接下我们通过一个例子来说明两者区别：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("setTimeout(()=>{\n    console.log('timer1')\n    Promise.resolve().then(function() {\n        console.log('promise1')\n    })\n}, 0)\nsetTimeout(()=>{\n    console.log('timer2')\n    Promise.resolve().then(function() {\n        console.log('promise2')\n    })\n}, 0)\n复制代码\n")])])]),s("p",[e._v("浏览器端运行结果："),s("code",[e._v("timer1=>promise1=>timer2=>promise2")])]),e._v(" "),s("p",[e._v("浏览器端的处理过程如下：")]),e._v(" "),s("p",[s("img",{attrs:{src:"img/16841d6392e8f537",alt:"img"}})]),e._v(" "),s("p",[e._v("Node端运行结果分两种情况：")]),e._v(" "),s("ul",[s("li",[e._v("如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为"),s("code",[e._v("timer1=>promise1=>timer2=>promise2")])]),e._v(" "),s("li",[e._v("如果是node10及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。\n"),s("ul",[s("li",[e._v("如果是第二个定时器还未在完成队列中，最后的结果为"),s("code",[e._v("timer1=>promise1=>timer2=>promise2")])]),e._v(" "),s("li",[e._v("如果是第二个定时器已经在完成队列中，则最后的结果为"),s("code",[e._v("timer1=>timer2=>promise1=>promise2")]),e._v("(下文过程解释基于这种情况下)")])])])]),e._v(" "),s("p",[e._v("1.全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；")]),e._v(" "),s("p",[e._v("2.首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；")]),e._v(" "),s("p",[e._v("3.至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2")]),e._v(" "),s("p",[e._v("Node端的处理过程如下：")]),e._v(" "),s("p",[s("img",{attrs:{src:"img/16841d5f85468047",alt:"img"}})]),e._v(" "),s("h2",{attrs:{id:"六、总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、总结"}},[e._v("#")]),e._v(" 六、总结")]),e._v(" "),s("p",[e._v("浏览器和Node 环境下，microtask 任务队列的执行时机不同")]),e._v(" "),s("ul",[s("li",[e._v("Node端，microtask 在事件循环的各个阶段之间执行")]),e._v(" "),s("li",[e._v("浏览器端，microtask 在事件循环的 macrotask 执行完之后执行")])])])}),[],!1,null,null,null);t.default=i.exports}}]);