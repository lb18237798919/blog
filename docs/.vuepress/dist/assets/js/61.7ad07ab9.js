(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{424:function(e,a,t){"use strict";t.r(a);var n=t(42),s=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"写-react-vue-项目时为什么要在列表组件中写-key-其作用是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写-react-vue-项目时为什么要在列表组件中写-key-其作用是什么"}},[e._v("#")]),e._v(" 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么")]),e._v(" "),t("blockquote",[t("p",[e._v('当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM。 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by="$index"。')])]),e._v(" "),t("p",[e._v("这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。")]),e._v(" "),t("ul",[t("li",[e._v("避免对节点「就地复用」")])]),e._v(" "),t("p",[e._v("需要修改的节点位置没有改变，是内容更新了，这虽然提高了复用性能，但是往往在复杂的表单会导致状态出现错位。也不会产生过度效果")]),e._v(" "),t("ul",[t("li",[e._v("key相当于每个vnode 的唯一id，我们可以依靠"),t("code",[e._v("key")]),e._v("，更快更精确的知道oldVnode中对应的vnode节点。")])]),e._v(" "),t("p",[e._v("带key就不会使用就定复用了，在sameNode函数"),t("code",[e._v("a.key===b.key")]),e._v("对比中可以避免就地复用的情况。")]),e._v(" "),t("p",[e._v("我们可以利用key的唯一性来更快获取到对应节点，比遍历更快。")]),e._v(" "),t("h2",{attrs:{id:"什么是diff算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是diff算法"}},[e._v("#")]),e._v(" 什么是diff算法？")]),e._v(" "),t("p",[e._v("要渲染真实的DOM的开销很大，因为改变真实dom，会当值整个dom树的重绘和回流。我们需要渲染真实dom的时候往往会把生成一个"),t("code",[e._v("虚拟节点")]),e._v(" virtual DOM，当virtual dom某个节点的数据改变后生成一个新的Vnode，然后将Vnode和oldVnode对比，当然有不同的地方教就直接修改在真实DOM上，然后是oldVnode=Vnode")]),e._v(" "),t("ul",[t("li",[e._v("真实DOM")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<div>\n    <p>123</p>\n</div>\n")])])]),t("ul",[t("li",[e._v("virtual DOM （虚拟DOM）")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var Vnode={\n    tag:'div',\n    children:[{\n        tag:'p',text:'123'\n    }]\n    \n}\n")])])]),t("h3",{attrs:{id:"diff的比较方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff的比较方式"}},[e._v("#")]),e._v(" diff的比较方式")]),e._v(" "),t("p",[e._v("在同层级进行，不会跨层级比较")]),e._v(" "),t("p",[e._v("oldDOM")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<div>\n    <p>123</p>\n</div>\n")])])]),t("p",[e._v("newDOM")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<div>\n    <span>2222</span>\n</div>\n")])])]),t("p",[t("img",{attrs:{src:"img/bVbvtvU",alt:"clipboard.png"}})]),e._v(" "),t("ul",[t("li",[e._v("先对比DIV，发现两个DIV不对等")]),e._v(" "),t("li",[e._v("查看DIV的子元素P、SPAN，发现不对等")]),e._v(" "),t("li",[e._v("查看P、SPAN没有子元素，则移除P，增加SPAN")])]),e._v(" "),t("p",[t("img",{attrs:{src:"img/bVbvtwL",alt:"clipboard.png"}})]),e._v(" "),t("p",[e._v("现在我们来看看在进行替换")]),e._v(" "),t("h4",{attrs:{id:"对比节点函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比节点函数"}},[e._v("#")]),e._v(" 对比节点函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function patch(oldVnode, vnode) {\n  // 对比是否相等\n  if (sameVnode(oldVnode, vnode)) {\n    patchVnode(oldVnode, vnode)\n  } else {\n    const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点\n    let parentEle = api.parentNode(oEl) // 父元素\n\n    createELe(vnode) // 为vnode生成新的元素\n\n    if (parentEle !== null) {\n      api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新的元素添加到父元素中\n      api.removeChild(parentEle, oldVnode.el) // 移除以前的元素\n    }\n  }\n\n  return vnode\n}\n")])])]),t("h4",{attrs:{id:"判断两者是否相同函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断两者是否相同函数"}},[e._v("#")]),e._v(" 判断两者是否相同函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function sameVnode(a, b) {\n  return (\n    a.key === b.key && // 对比key\n    a.tag === b.tag && // 对比标签名\n    a.isComment === b.isComment && // 是否为注释节点\n    isDef(a.data) === isDef(b.data) && // 是否定义了data，或者其他属性\n    sameInputType(a, b) //判断是当<Input>时 是否type相同\n  )\n}\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);