(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{416:function(t,e,a){"use strict";a.r(e);var r=a(42),o=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"有以下-3-个判断数组的方法-请分别介绍它们之间的区别和优劣"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有以下-3-个判断数组的方法-请分别介绍它们之间的区别和优劣"}},[t._v("#")]),t._v(" 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣")]),t._v(" "),a("h4",{attrs:{id:"_1-object-prototype-tostring-call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-object-prototype-tostring-call"}},[t._v("#")]),t._v(" 1. Object.prototype.toString.call()")]),t._v(" "),a("p",[t._v("每一个继承 Object 的对象都有 "),a("code",[t._v("toString")]),t._v(" 方法，如果 "),a("code",[t._v("toString")]),t._v(" 方法没有重写的话，会返回 "),a("code",[t._v("[Object type]")]),t._v("，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 "),a("code",[t._v("toString")]),t._v(" 方法时，会直接返回都是内容的字符串，所以我们需要使用call或者apply方法来改变toString方法的执行上下文。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const an = ['Hello','An'];\nan.toString(); // \"Hello,An\"\nObject.prototype.toString.call(an); // \"[object Array]\"\n")])])]),a("p",[t._v("这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('Object.prototype.toString.call(\'An\') // "[object String]"\nObject.prototype.toString.call(1) // "[object Number]"\nObject.prototype.toString.call(Symbol(1)) // "[object Symbol]"\nObject.prototype.toString.call(null) // "[object Null]"\nObject.prototype.toString.call(undefined) // "[object Undefined]"\nObject.prototype.toString.call(function(){}) // "[object Function]"\nObject.prototype.toString.call({name: \'An\'}) // "[object Object]"\n')])])]),a("p",[a("code",[t._v("Object.prototype.toString.call()")]),t._v(" 常用于判断浏览器内置对象时。")]),t._v(" "),a("p",[t._v("更多实现可见 "),a("a",{attrs:{href:"https://juejin.im/post/591647550ce4630069df1c4a",target:"_blank",rel:"noopener noreferrer"}},[t._v("谈谈 Object.prototype.toString"),a("OutboundLink")],1)]),t._v(" "),a("h4",{attrs:{id:"_2-instanceof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-instanceof"}},[t._v("#")]),t._v(" 2. instanceof")]),t._v(" "),a("p",[a("code",[t._v("instanceof")]),t._v(" 的内部机制是通过判断对象的原型链中是不是能找到类型的 "),a("code",[t._v("prototype")]),t._v("。")]),t._v(" "),a("p",[t._v("使用 "),a("code",[t._v("instanceof")]),t._v("判断一个对象是否为数组，"),a("code",[t._v("instanceof")]),t._v(" 会判断这个对象的原型链上是否会找到对应的 "),a("code",[t._v("Array")]),t._v(" 的原型，找到返回 "),a("code",[t._v("true")]),t._v("，否则返回 "),a("code",[t._v("false")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("[]  instanceof Array; // true\n")])])]),a("p",[t._v("但 "),a("code",[t._v("instanceof")]),t._v(" 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("[]  instanceof Object; // true\n")])])]),a("h4",{attrs:{id:"_3-array-isarray"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-array-isarray"}},[t._v("#")]),t._v(" 3. Array.isArray()")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("功能：用来判断对象是否为数组")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("Array.isArray()")]),t._v(" 与 "),a("code",[t._v("Object.prototype.toString.call()")])]),t._v(" "),a("p",[a("code",[t._v("Array.isArray()")]),t._v("是ES5新增的方法，当不存在 "),a("code",[t._v("Array.isArray()")]),t._v(" ，可以用 "),a("code",[t._v("Object.prototype.toString.call()")]),t._v(" 实现。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("if (!Array.isArray) {\n  Array.isArray = function(arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n  };\n}\n")])])])])])])}),[],!1,null,null,null);e.default=o.exports}}]);